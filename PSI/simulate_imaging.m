function [OBS, GT_movie]= simulate_imaging(GT, opts)
%simulates the imaging process
%outputs
%   OBS.data_in: the photodetector signal 
%   GT_movie: a noiseless movie of the sample

%inputs
%   GT: Ground truth generated by simulate_sample

if opts.do3D
    error('We don''t support the 3D case yet');
end

%OBS.IM: morphological data. Will be used in reconstruction. 
OBS.IM = GT.IM; %for now, we assume the morphological image was a faithful representation of the sample
                    %TO DO: Warp the image, etc.
                    
OBS.data_in = zeros(size(opts.P,2), opts.nframes); %extize

if nargout>1
    GT_movie = zeros([size(GT.IM) opts.nframes]);
end

for frame = 1:opts.nframes
    disp(['     Frame ' int2str(frame)])
    %generate the brightness of this frame
    F = GT.seg.seg(GT.seg.bw,:)*(1+GT.activity(:,frame)); %fluorescence intensity of pixels within the mask
    thisframe = GT.IM;
    thisframe(GT.seg.bw) = F; %add fluorescence signal

    %add unsuspected activity
    thisframe = thisframe + reshape(GT.unsuspected.Su*(1+GT.unsuspected.Fu(:,frame)), size(GT.IM));
    
    if nargout>1
        GT_movie(:,:,frame) = thisframe; %the ground truth brightness of the sample, without sample motion
    end

    
    %shift the frame according to the per-frame motion
    dX = round(GT.motion.pos(1,frame)); dY = round(GT.motion.pos(2,frame));
    shifted = apply_motion(thisframe, [dX dY], '2D');
    
    dark_photons = opts.scope.darkrate/opts.samplerate;
    signal_photons = shifted(:)'*opts.P;
    
    %#photons impinging on PMT at each time
    photons_sampled = poissrnd(signal_photons+dark_photons);
    if opts.debug.nonoise
        photons_sampled = signal_photons+dark_photons;
    end
    
    %data collected is:            photons    +                   noise due to pulseheight variation                     +            electronics noise                   
    OBS.data_in(:,frame) =    photons_sampled + sqrt(photons_sampled).*randn(size(photons_sampled)).*opts.scope.PMTsigma + opts.scope.readnoise*randn(size(photons_sampled));
end
end